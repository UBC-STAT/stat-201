---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.1
  kernelspec:
    display_name: R
    language: R
    name: ir
---

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "f6603894375551164129b4457e34d41d", "grade": false, "grade_id": "cell-c2af283376010ebb", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
# Week 7: Confidence Intervals (of means and proportions) Based on the Assumption of Normality or the Central Limit Theorem
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "d3fe52742b85ffe27acd10acc1528cd3", "grade": false, "grade_id": "cell-7c081b8839e00f79", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
#### Lecture and Tutorial Learning Goals:
From this section, students are expected to be able to:

1. Describe the Law of Large Numbers.
2. Describe a normal distribution.
3. Explain the Central Limit Theorem and its role in constructing confidence intervals.
4. Write a computer script to calculate confidence intervals based on the assumption of normality / the Central Limit Theorem.
5. Discuss the potential limitations of these methods.
6. Decide whether to use asymptotic theory or bootstrapping to compute estimator uncertainty.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'c502f6e9e17904ab118c9a0a6a26934f', 'grade': False, 'grade_id': 'cell-65e6f8aa132b1a29', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# Run this cell before continuing.
library(cowplot)
library(datateachr)
library(digest)
library(infer)
library(repr)
library(taxyvr)
library(tidyverse)
source("tests_tutorial_07.R")
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "fff73c58c36840e1568167c297bb86be", "grade": false, "grade_id": "cell-01839419b350b0e6", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 1. Estimating the Mean using CLT

In this section, we will use the Central Limit Theorem to obtain interval estimates (i.e., confidence intervals) for the population mean instead of the simulation approach we used in Week 4. 

The US Food & Drug Administration (FDA) monitored the mercury level in many different commercial fishes and shellfish between 1990 and 2010. The mercury levels were measured in parts per million (ppm). This study is very relevant because a high mercury level is toxic to people and can cause brain problems and affect the fetus. Pretty serious!! 

Let us start by loading and taking a peek at the dataset.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '8d1b4437571749b5ed64d732fcf4e110', 'grade': False, 'grade_id': 'cell-3a1222d9cac28f43', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
salmon <- read_csv("salmon.csv")
head(salmon)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "66172ae584fe7d675b28bf8d257024be", "grade": false, "grade_id": "cell-ffeef6745cd01c23", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.1**
<br> {points: 1}

Since we will be relying on the CLT, it is good to check if there is no severe violation of the CLT's assumptions. A good first step is to check the sample distribution to understand what sort of distribution we are dealing with. Remember that the sample distribution is an estimate of the population distribution. This step is important because "weird" distributions, such as asymmetric and/or multimodal distributions **might** require bigger sample sizes for the CLT to kick-in.

Your job in this exercise is to plot the histogram of `mercury_concentration` of salmon. 

_Assign your plot to an object called `salmon_sample_dist`._
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '0ce1faece9f6096c52eb8d8bc760e329', 'grade': False, 'grade_id': 'cell-505475c31feb4ce8', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# your code here
fail() # No Answer - remove if you provide an answer

salmon_sample_dist
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '16bcd112eda31397402a0a7f9a80690f', 'grade': True, 'grade_id': 'cell-2341e1f3b090bbfb', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "4513e22ba8b89d721476ae7751c8cf9d", "grade": false, "grade_id": "cell-8313321fcd62d878", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.2**
<br>{points: 1}

Based on the previous question's sample distribution plot, select all that apply:

A. The distribution is symmetric;

B. The distribution is left-skewed;

C. The distribution is right-skewed;

D. The distribution is multimodal;

E. The distribution is unimodal;

F. The distribution is quite similar to the Normal distribution;

_Assign your answer to an object called `answer1.2`. Your answer should be a sequence of characters surrounded by quotes, e.g., "ACF"._
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4cbc5bb683c2e73a2d8499589942fc0d', 'grade': False, 'grade_id': 'cell-26d36a2f8841840b', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# answer1.2 <- ...

# your code here
fail() # No Answer - remove if you provide an answer
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '56f769c65c82143f480d1f865c8f8326', 'grade': True, 'grade_id': 'cell-aad2cf21c6f6f4e5', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
# Here we check to see if you have given your answer the correct object name
# and if your answer is plausible. However, all other tests have been hidden
# so you can practice deciding when you have the correct answer.
test_that('Did not assign answer to an object called "answer1.2"', {
  expect_true(exists("answer1.2"))
})

```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "e8c940d8f9b949b46f64ddda291238fb", "grade": false, "grade_id": "cell-abc6d7359bcc1fd8", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.3**
<br> {points: 4}

The previous question showed that the population is quite asymmetric, with most salmons presenting low mercury levels but some salmons presenting much higher levels. Asymmetry, especially with outliers, might require a larger **n** for the CLT to kick in. On the other hand, our sample size is already somewhat large, with 94 fish in the sample. 

Remember that, if the conditions are satisfied, the CLT states that the $\bar{X}\sim N\left(\mu, \frac{\sigma}{\sqrt{n}}\right)$ . 

If you have a strong suspicion that your sample size is not large enough, you might want to consider using the bootstrap approach. Let's take a look at the approximation of the sampling distribution provided by both approaches: bootstrap and CLT. Let's use the sample mean and standard deviation as placeholders for $\mu$ and $\sigma$, respectively, in the case of CLT.

Your job:

1. Calculate the sample mean and store it in an object called `salmon_x_bar`. Note: `salmon_x_bar` must be a number, not a `tibble`.
2. Calculate the estimate of the standard error of $\bar{X}$ and store it in an object called `salmon_std_error`. Note: `salmon_std_error` must be a number, not a `tibble`.
3. Obtain the bootstrap sampling distribution using 2000 bootstrap samples and store them in a data frame called `salmon_btsp_samp_dist`. Note: the data frame `salmon_btsp_samp_dist` must have two columns only: (1) `replicate`; and (2) `stat`.
4. Create the histogram to visualize the bootstrap sampling distribution vs the Normal density given by the CLT. Assign your plot to an object called `salmon_btsp_vs_clt_samp_dist_plot`.
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '05d074cb3de7a07cc1166369e9774910', 'grade': False, 'grade_id': 'cell-6e7a7cfa050817e0', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(20210201) # Do not change this

# # Obtain the sample mean
# salmon_x_bar <- mean(salmon$...)

# # Obtain the sample std. error 
# salmon_std_error <- ...

# # Done for you: the normal curve
# clt_samp_dist <- 
#     tibble(x = seq(salmon_x_bar - 4 * salmon_std_error, 
#                    salmon_x_bar + 4 * salmon_std_error, 0.0001),
#            density = dnorm(x, salmon_x_bar, salmon_std_error))

# # Obtain the boostrap sampling distribution
# salmon_btsp_samp_dist <-
#     salmon %>% 
#     ...

# # Let's plot the bootstrap vs the CLT estimates
# salmon_btsp_vs_clt_samp_dist_plot <- 
#     salmon_btsp_samp_dist %>% 
#     ggplot() + 
#     geom_histogram(aes(..., ..density..), color = 'white') + 
#     geom_line(data = clt_samp_dist, aes(x, density), lwd = 2, color = "red") + 
#     ... + 
#     ... + 
#     theme(text = element_text(size = 20))

# your code here
fail() # No Answer - remove if you provide an answer

salmon_btsp_vs_clt_samp_dist_plot
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '3a3ee4441909e5e6bde0eecd3c38492c', 'grade': True, 'grade_id': 'cell-4d977cd79601c36c', 'locked': True, 'points': 4, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.3()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "9173c76d5131a81cb3566090056ac591", "grade": false, "grade_id": "cell-139b4197575ce68c", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
As we can see from the plot above, the sampling distribution estimates given by the CLT and boostrap approaches are fairly close. Therefore, from this similarity, we could already expect that both confidence intervals will be similar. 
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "12a17888c6fbf79580f96df45876fc80", "grade": false, "grade_id": "cell-668136ec5fe49a52", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.4** 
<br> {points: 1}


Obtain the 92.8% confidence interval for the mean mercury levels in fish and shellfish applying the CLT.

_Assign your data frame to an object called `salmon_clt_ci`. The data frame should have two columns: (1) `lower_ci`; and `upper_ci`_
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'cc1729eb30874d8411f140961c82fecc', 'grade': False, 'grade_id': 'cell-fc98a923c0c14e96', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# salmon_clt_ci <- 
#     tibble(lower_ci = ... + qnorm(...) * ..., 
#            upper_ci = ... )

# your code here
fail() # No Answer - remove if you provide an answer

head(salmon_clt_ci)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '9a4a7bfe5845ddc31c67d3944cbbea25', 'grade': True, 'grade_id': 'cell-f7e0b7f67926de11', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
# Here we check to see if you have given your answer the correct object name
# and if your answer is plausible. However, all other tests have been hidden
# so you can practice deciding when you have the correct answer.
test_that('Did not assign answer to an object called "salmon_clt_ci"', {
  expect_true(exists("salmon_clt_ci"))
})
test_that("Solution should be a data frame", {
  expect_true("data.frame" %in% class(salmon_clt_ci))
})
test_that("Data frame does not contain the correct number of rows", {
  expect_equal(digest(as.integer(nrow(salmon_clt_ci))), "4b5630ee914e848e8d07221556b0a2fb")
})


```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "2af148f6c73fdaab462fb3192261c667", "grade": false, "grade_id": "cell-88f74a6c5fda18d5", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 1.5** 
<br> {points: 1}


Obtain the 92.8% confidence interval for the mean mercury levels in fish and shellfish using the bootstrap distribution you obtained previously: `salmon_btsp_samp_dist`.

_Assign your data frame to an object called `salmon_btsp_ci`. The data frame should have two columns: (1) `lower_ci`; and `upper_ci`_
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '73e626b70f7f29da97d4c0674a37c2b3', 'grade': False, 'grade_id': 'cell-1168254298238bad', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# salmon_btsp_ci <- 
#     salmon_btsp_samp_dist %>% 
#     ...

# your code here
fail() # No Answer - remove if you provide an answer

head(salmon_btsp_ci)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'da826cc0c38aae45f704bd63583d877a', 'grade': True, 'grade_id': 'cell-4a8b5c77767d3335', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_1.5()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "911eeeaacb51b345d019f07386b9964c", "grade": false, "grade_id": "cell-a554f04c00004696", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
As we imagined, the CLT and bootstrap confidence intervals are quite close.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "e81b4f8943361dc6112fdda6c14c7c67", "grade": false, "grade_id": "cell-5bb24b0c5edc5ded", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 2. Estimating the Difference in Means using CLT
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "51b2357f047c2cf637a6ffd78292d8cb", "grade": false, "grade_id": "cell-c5ccd82df7ec91ab", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Is parking in Downtown Vancouver more expensive than in Kitsilano?
For this question, we will use the Vancouver parking meter data set. 
First, let's preview the dataset.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '2df44a8bff2f585be9bbce784638a726', 'grade': False, 'grade_id': 'cell-89379583801bf044', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
?parking_meters
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '537fa03e303a2825e2375f5c043b467a', 'grade': False, 'grade_id': 'cell-8bb6be6fd6461cd8', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
head(parking_meters)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "298eef3377df67b482b633c34f4f0af3", "grade": false, "grade_id": "cell-9700be8c7785053a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Let's focus on 9 am to 10 pm Monday to Friday's rate. We will take a sample of 53 downtown meters and a sample of 40 Kitsilano meters. The sample is stored in `downtown_kitsilano_sample`.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '9d051632f6a01af9cbab947ca65891c6', 'grade': False, 'grade_id': 'cell-5101e5167f562c33', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# Run this cell before continuing

set.seed(4759)

parking_pop <- # Some data cleaning
    parking_meters %>% 
    filter((geo_local_area %in% c("Downtown", "Kitsilano")) & (!is.na(r_mf_9a_6p))) %>%
    select(geo_local_area, r_mf_9a_6p) %>% 
    mutate(r_mf_9a_6p = as.numeric(str_remove(r_mf_9a_6p, "\\$")))

downtown_kitsilano_sample <- # Taking the sample
    parking_pop %>% 
    group_by(geo_local_area) %>% 
    sample_n(size = case_when(geo_local_area == "Downtown" ~ 53,
                              geo_local_area == "Kitsilano" ~ 40), replace = FALSE) %>% 
    ungroup()

downtown_kitsilano_sample %>% # Let's take a peek
    group_by(geo_local_area) %>% 
    sample_n(size = 3)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "b383ac8981bb8291b144dee3519be086", "grade": false, "grade_id": "cell-58fd73de5fcd5c27", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.1**
<br> {points: 1}

As usual, let's start by checking the sample distribution of each neighbourhood. Use `binwidth = 1`.

_Assign your plot to an object called `parking_samp_dist_plot`._
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'f928e1743d2a4adbffb17137c37aef5a', 'grade': False, 'grade_id': 'cell-61c19e838da29421', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# parking_samp_dist_plot <- 
#     downtown_kitsilano_sample %>% 
#     ... + 
#     ...(..., ... = 1, color = 'white') +
#     facet_wrap(~ geo_local_area) + 
#     ...
#     theme(text = element_text(size = 22))


# your code here
fail() # No Answer - remove if you provide an answer

parking_samp_dist_plot
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '1daaf27469f904aa9dacf6f99cf66530', 'grade': True, 'grade_id': 'cell-ceb4f6891dbf13a9', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_2.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "f7f88f759ea4df07f18b5f3aec3f07d9", "grade": false, "grade_id": "cell-8bf35263fd5b0e8a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.2** 
<br> {points: 1}

Obtain the sample averages of parking rates for each region, `Kitsilano` and `Downtown`, as well as their standard error.

_Assign your data frame to an object called `parking_summary`. The data frame should have three columns: (1) `geo_local_area`; (2) `sample_mean`; and (3) `sample_std_error`_
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'ff667a6b78e17c843060683e9ec073f3', 'grade': False, 'grade_id': 'cell-ad6b08b245fcd5b1', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# your code here
fail() # No Answer - remove if you provide an answer

head(parking_summary)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '971c67457db6015e9e84b9a9caa8d1e3', 'grade': True, 'grade_id': 'cell-9cc24470ed6dc564', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_2.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "78902e7f19c25469d6e465cf80f43f3b", "grade": false, "grade_id": "cell-1da961ba5a8fef3f", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.3** 
<br> {points: 1}

Obtain a 94% confidence interval for the difference between the means of Downtown and Kitsilano's parking rates using the CLT. 

_Assign your data frame to an object called `parking_clt_ci`. The data frame should have two columns: `lower_ci` and `upper_ci`._
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '58649750da27574c9a9606eae4853a56', 'grade': False, 'grade_id': 'cell-c76bedd3b1c241b6', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# downtown_mean <- parking_summary$...
# downtown_var <- ...
# kits_mean <- ...
# kits_var <- ...

# parking_clt_ci <- 
#     tibble(lower_ci = ...,
#            upper_ci = ...)

# your code here
fail() # No Answer - remove if you provide an answer

head(parking_clt_ci)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '22bc1a718591cfc917ec8ff190259f79', 'grade': True, 'grade_id': 'cell-94b7ce714b831581', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
# Here we check to see if you have given your answer the correct object name
# and if your answer is plausible. However, all other tests have been hidden
# so you can practice deciding when you have the correct answer.
test_that('Did not assign answer to an object called "parking_clt_ci"', {
  expect_true(exists("parking_clt_ci"))
})
test_that("Solution should be a data frame", {
  expect_true("data.frame" %in% class(parking_clt_ci))
})

```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "40f009407c0e7258e73b55bfbb9cfa5e", "grade": false, "grade_id": "cell-accda98a2b390651", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 2.4**
<br> {points: 1}


Are these intervals accurate? In other words, if we were to do this process multiple times, will we capture the true parking rate difference approximately 94% of the time?  This is what we are going to investigate in this exercise. We have already taken 100 samples saved in the `parking_multiple_ci` object. 

Your job is:
1. add two columns to the `parking_multiple_ci` data frame, namely, `lower_ci` and `upper_ci` with the lower and upper bound of the respective confidence interval. 
2. add a third column, `captured`, with `TRUE` or `FALSE`, if the interval captured the true difference. 
3. finally, select only the `replicate`, `lower_ci`, `upper_ci`, and `captured` columns.


_Assign your plot to an object called `parking_multiple_ci`._
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '910824368b3dea30ccaa7e24d72601c0', 'grade': False, 'grade_id': 'cell-320b591ff02f2dcd', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
# Run this cell before continuing

set.seed(20210301) # Do not change this.

# Obtain the means of parking rates in each neighbourhood.
true_means <-
    parking_pop %>% 
    group_by(geo_local_area) %>% 
    summarise(sample_mean = mean(r_mf_9a_6p)) %>% 
    pull(sample_mean)

# Obtain the true difference in mean
true_diff = true_means[1] - true_means[2]

parking_multiple_samples <- 
    tibble(replicate = 1:100) %>% 
    mutate(sample = map(replicate,
                        `.f` = ~
                            parking_pop %>% 
                            group_by(geo_local_area) %>% 
                            sample_n(size = case_when(geo_local_area == "Downtown" ~ 53,
                                                      geo_local_area == "Kitsilano" ~ 40), replace = FALSE) %>% 
                            ungroup() 
                    )
    ) %>% 
    unnest(sample) %>% 
    group_by(replicate, geo_local_area) %>% 
    summarise(sample_mean = mean(r_mf_9a_6p),
              sample_std_error = sd(r_mf_9a_6p)/sqrt(n()),
              n = n()) %>% 
    pivot_wider(names_from = geo_local_area, values_from = c(sample_mean, sample_std_error, n))

head(parking_multiple_samples)
```

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '4226a51932690afa880e78b221eb680a', 'grade': False, 'grade_id': 'cell-b2f055d4516416ac', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# parking_multiple_ci <-
#     parking_multiple_samples %>% 
#     mutate(lower_ci = ...,
#            upper_ci = ...) %>% 
#     select(replicate, lower_ci, upper_ci) %>% 
#     mutate(captured = between(true_diff, ..., ...))


# your code here
fail() # No Answer - remove if you provide an answer

head(parking_multiple_ci)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd9fc89e81bc94af9245a0e696490071f', 'grade': True, 'grade_id': 'cell-d112254b32c744cc', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_2.4()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "66585ee1a337afcd8adf6266d8086f9c", "grade": false, "grade_id": "cell-157421d1b1768043", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Nice job! Run the cell below to visualize the confidence intervals.
<!-- #endregion -->

```{r}
parking_multiple_ci %>% 
    ggplot() +
    scale_colour_manual(breaks = c("TRUE", "FALSE"), # Change colour scale for better visibility.
                        values = c("grey", "black")) +
    geom_segment(aes(x = lower_ci,
                     xend = upper_ci,
                     y = replicate,
                     yend = replicate,
                     colour = captured)) +
    geom_vline(xintercept = true_diff, colour = "red", size = 1) +
    labs(title = "100 90% Confidence Intervals",
         x = 'Difference in means',
         y = "Sample ID",
         colour = "Captured?") +
    theme_bw() + # Sets a theme for better visibility.
    theme(text = element_text(size = 18)) 
    
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "810c4a4ecffa5661cf76147e7bd1d1a4", "grade": false, "grade_id": "cell-181ab17fe26a6a50", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
As you can see, the CLT approximation seems quite reasonable, even though our population is not Normal.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "d9926e986fef31225f8da0487a5afa55", "grade": false, "grade_id": "cell-43ca3aa53c81359d", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 3. Estimating Proportions using CLT

There was a provincial election in British Columbia in 2020. Before the election, the pollsters were hard at work trying to estimate the proportion of votes each party would get if the election happened when the data was collected. In this section, we will work with a data set from [a poll performed by the Angus Reid Institute](https://angusreid.org/bc-election-post-debate/) that asked people which party they intended to vote for. Let's start by reading the data set.

<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '643cbafabe27c5f167488b1cb0230e5e', 'grade': False, 'grade_id': 'cell-3f476650f00a2175', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
polls <- 
    read_csv("angus_reid_poll.csv") %>% 
    mutate(party = as.factor(party))

head(polls)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "d4180ce3299e8be668e48bcd6330d8ac", "grade": false, "grade_id": "cell-a2326ccc916cf24e", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.1** 
<br> {points: 1}

Since we intend to use the CLT, let us start by calculating the quantities that we need:

1. the total number of votes each party received, this should be stored in a column named `n`;
2. the proportion of votes each party received, this should be stored in a column named `prop`;
3. the standard error of the sample proportion of each party, which should be stored in a column named `se`;
3. lower and upper boundaries of the 95% confidence interval, stored in columns `lower_ci` and `upper_ci` respectively;

_Assign your data frame to an object called `polls_summary`._
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '7b53a7f642608bc98776e6004121caf5', 'grade': False, 'grade_id': 'cell-ff46d1939db8240a', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# polls_summary <- 
#     polls %>% 
#     ... %>% 
#     summarise(n =  n(),
#               prop = ...,              
#               se = ...,
#               lower_ci = ...,
#               upper_ci = ...) %>% 
#     mutate(party = fct_reorder(party, prop, .desc = TRUE))

# your code here
fail() # No Answer - remove if you provide an answer

head(polls_summary)
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '2ab0a987c2a5b06860dc85772b0f2e88', 'grade': True, 'grade_id': 'cell-17b4f1c1973d3ee8', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
# Here we check to see if you have given your answer the correct object name
# and if your answer is plausible. However, all other tests have been hidden
# so you can practice deciding when you have the correct answer.
test_that('Did not assign answer to an object called "polls_summary"', {
  expect_true(exists("polls_summary"))
})
test_that("Solution should be a data frame", {
  expect_true("data.frame" %in% class(polls_summary))
})
expected_colnames <- c("party", "prop", "n", "se", "lower_ci", "upper_ci")

given_colnames <- colnames(polls_summary)
test_that("Data frame does not have the correct columns", {
  expect_equal(length(setdiff(
    union(expected_colnames, given_colnames),
    intersect(expected_colnames, given_colnames)
  )), 0)
})

test_that("Data frame does not contain the correct number of rows", {
  expect_equal(digest(as.integer(nrow(polls_summary))), "234a2a5581872457b9fe1187d1616b13")
})


```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "4430840c970eea88c47adfbf5d5e1cf7", "grade": false, "grade_id": "cell-fe486c881a7e169a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
How about we visualize the information you obtained with a plot? 
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'bfd1e419c31bb5f8c19ca9ddad3ca2cd', 'grade': False, 'grade_id': 'cell-ae789f888efdcffa', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
options(repr.plot.width = 10, repr.plot.height = 8)

poll_ci_plot <- 
    polls_summary %>% 
    ggplot(aes(x = party, y = prop, fill=party)) +
      geom_bar(stat = "identity", 
               colour="black",
               alpha = .6) +
      geom_errorbar(aes(ymin = lower_ci, ymax = upper_ci),
                    size = 0.5, color = "black", width=.2) +
      theme_bw() +
      xlab("Political party") +
      ylab("Proportion intending to vote") +
      theme(text = element_text(size = 20)) + 
      ggtitle("Poll BC 2020 election")

poll_ci_plot
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "b28555af924c776386ce2a6fd66ee76f", "grade": false, "grade_id": "cell-d21f147740f1292e", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
**Question 3.2** 
<br> {points: 3}

Use written English to interpret and report the estimates (and their confidence intervals) for each party. Is there any concern over using the CLT to obtain the confidence interval for the proportion for any of the parties?
<!-- #endregion -->

<!-- #region deletable=false nbgrader={"cell_type": "markdown", "checksum": "60afdf82d5fa6b5e6e12c8a91c70e6dc", "grade": true, "grade_id": "cell-de06e53cd1d8d152", "locked": false, "points": 3, "schema_version": 3, "solution": true, "task": false} -->

DOUBLE CLICK TO EDIT **THIS CELL** AND REPLACE THIS TEXT WITH YOUR ANSWER.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "c456319a778d8d01a8306bc2c9fe78bf", "grade": false, "grade_id": "cell-60a87776067987a6", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
## 4. Estimating difference in proportions using CLT

In Question 3 of Tutorial 6, we used the [Breast Cancer](https://archive.ics.uci.edu/ml/datasets/Breast+Cancer) data set and studied the effects of radiation therapy on the recurrence of breast cancer. Now, we will obtain the confidence interval of the difference in proportions by bootstrapping and CLT.
<!-- #endregion -->

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'bcbbbfed5f082ddbb8d252099faa6297', 'grade': False, 'grade_id': 'cell-5c7a76ec0020781c', 'locked': True, 'schema_version': 3, 'solution': False, 'task': False}}
breast_cancer <- 
    read_csv(url("https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer/breast-cancer.data"), 
             col_names = c("class", "age", "menopause", "tumor-size", "inv-nodes", "node-caps", "deg-malig", "breast", "breast-quad", "irradiat")) %>% 
    select(class, irradiat)

# Taking a peek of the data set
breast_cancer %>% 
    group_by(class,irradiat) %>% 
    sample_n(size = 2)
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "11f0d11359c24c46b6a9dad2ef4f86f5", "grade": false, "grade_id": "cell-2e298ff81e52730d", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
Let $p_{1}$ be the proportion of patients with past radiation treatment (irradiate=yes) that had recurrent cancer, and let $p_{2}$ be the proportion of patients with no radiation treatment (irradiate=no) that had recurrent cancer. We would like to study $p_1-p_2$ and find its 95% confidence interval.
<!-- #endregion -->

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "f0caf343d1fe011fb6bd1d0c06ec3497", "grade": false, "grade_id": "cell-a2282e8e593dc225", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
<b>Question 4.1: Sample Proportions</b>
<br>{points: 1}

Find the sample proportions of $p_1$ (proportion of patients with radiation treatment with recurrent cancer) and $p_2$ (proportion of patients without radiation treatment with recurrent cancer).

<i>Assign your answers to a data frame named `p_summary`. The data frame should have four columns: `p_yes` and `p_no`, `n_yes`, `n_no`.</i>
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '09297ea7526bd98b597980e7cf55c34b', 'grade': False, 'grade_id': 'cell-fcd41e98689bf0b2', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# your code here
fail() # No Answer - remove if you provide an answer

p_summary
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'cb88c767e17cb0bd275d58cd102f5508', 'grade': True, 'grade_id': 'cell-6fb2812708724b85', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_4.1()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "4442f7be7998afd6bc608b30c849ce0c", "grade": false, "grade_id": "cell-d35d2b4be52c2ac9", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
<b> Question 4.2 </b>
<br>{points: 1}

Add two more columns to the `p_summary` data frame: 

1. `p_diff` to store the observed difference in proportion, i.e., $\hat{p_1}-\hat{p_2}$;
2. `p_diff_std_error` to store the sample standard error of the difference in proportions.
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'b436712039a868490435be3653d221d1', 'grade': False, 'grade_id': 'cell-6249970dc725cf18', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# p_summary <-
#     p_summary %>% 
#     mutate(p_diff = ...,
#            p_diff_std_error = ...)

# your code here
fail() # No Answer - remove if you provide an answer

p_summary
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '86818fd44216a4c7f3d8f9b7fcbb69cf', 'grade': True, 'grade_id': 'cell-13a5255d8373230c', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_4.2()
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "69a7b63e6e26fd7fa30e648ea8d4a297", "grade": false, "grade_id": "cell-1a7dd63aace9412d", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
<b>Question 4.3</b>
<br>{points: 1}

Finally, obtain the 95% confidence interval for the difference in proportion. Add two more columns to `p_summary` data frame: (1) `lower_ci`; and (2) `upper_ci`.
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'a9d1f2e02bfbe2de89fbbe6eb4f66d82', 'grade': False, 'grade_id': 'cell-86046e88f3a47b9e', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
# p_summary <- 
#     p_summary %>% 
#     mutate(lower_ci = qnorm(..., ..., ...),
#            upper_ci = ...)

# your code here
fail() # No Answer - remove if you provide an answer

p_summary
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': '55129edfe20b9f6c8b9946b5a64cc671', 'grade': True, 'grade_id': 'cell-301202705377a780', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
# Here we check to see if you have given your answer the correct object name
# and if your answer is plausible. However, all other tests have been hidden
# so you can practice deciding when you have the correct answer.

test_that('Did not assign answer to an object called "p_summary"', {
expect_true(exists("p_summary"))
})

test_that("Solution should be a data frame", {
expect_true("data.frame" %in% class(p_summary))
})

expected_colnames <- c("n_no", "n_yes", "p_no", "p_yes", "p_diff", "p_diff_std_error", "lower_ci", "upper_ci")
given_colnames <- colnames(p_summary)
test_that("Data frame does not have the correct columns", {
expect_equal(length(setdiff(
  union(expected_colnames, given_colnames),
  intersect(expected_colnames, given_colnames)
)), 0)
})

test_that("Data frame does not contain the correct number of rows", {
expect_equal(digest(as.integer(nrow(p_summary))), "4b5630ee914e848e8d07221556b0a2fb")
})
```

<!-- #region deletable=false editable=false nbgrader={"cell_type": "markdown", "checksum": "2176c547b5b3771ca553ab99dea12254", "grade": false, "grade_id": "cell-33bb912bc710294a", "locked": true, "schema_version": 3, "solution": false, "task": false} -->
<b>Question 4.4: Confidence Interval by Bootstrap</b>
<br>{points: 1}

Obtain the 95% confidence interval of the difference of proportions ($p_1-p_2$) via bootstrapping by generating 1000 samples from `breast_cancer`.
```r
diff_in_props_btsp_ci <- 
    breast_cancer %>%
    specify(formula = class ~ irradiat, success=...) %>%
    generate(...) %>%
    calculate(stat = ..., order = c(...)) %>%
    get_ci()
```
<i>Assign your answer to a variable called ` diff_in_props_btsp_ci`</i>.
<!-- #endregion -->

```{r deletable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'd68ac50582426f5d67743b6ccf6f2a24', 'grade': False, 'grade_id': 'cell-e80d61bc1a6048c1', 'locked': False, 'schema_version': 3, 'solution': True, 'task': False}}
set.seed(20210301) # Do not change this

# your code here
fail() # No Answer - remove if you provide an answer

diff_in_props_btsp_ci
```

```{r deletable=FALSE, editable=FALSE, nbgrader={'cell_type': 'code', 'checksum': 'e91f49ffdf7649f889975d111b3c4dd6', 'grade': True, 'grade_id': 'cell-c5dfba410a596cee', 'locked': True, 'points': 1, 'schema_version': 3, 'solution': False, 'task': False}}
test_4.4()
```
